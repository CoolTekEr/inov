#!/bin/bash

# Usage help information
usage() {
    echo "Usage: $0 <string1> <string2> <string3>"
    echo "Example: $0 value1 value2 value3"
}

# Check if all required arguments are provided
if [ "$#" -ne 3 ]; then
    usage
    exit 1
fi

# Set variables
STRING1=$1
STRING2=$2
STRING3=$3
URL="http://x.y.z.com"
HEADER="appid: YourAppID"

# Send POST request with fields and headers
RESPONSE=$(curl -s -X POST -H "$HEADER" -d "{\"string1\":\"$STRING1\",\"string2\":\"$STRING2\",\"string3\":\"$STRING3\"}" "$URL")

# Check response status
RESPONSE_CODE=$(echo "$RESPONSE" | awk '{print $2}')
if [ "$RESPONSE_CODE" -eq 200 ]; then
    # Extract the 'target' string from response JSON
    TARGET=$(echo "$RESPONSE" | grep -o '"target":"[^"]*' | cut -d'"' -f4)
    echo "Target: $TARGET"
else
    # Print user-friendly error message
    echo "Error: Request failed with response code $RESPONSE_CODE"
fi
@Entity
@Table(name = "products")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name")
    private String name;

    // ... other properties and methods
}
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    List<Product> findByNameLike(String searchTerm);

}

@Service
public class ProductService {

    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    public List<Product> searchProducts(String searchTerm) {
        return productRepository.findByNameLike("%" + searchTerm + "%");
    }
}
#!/bin/bash

# Variables
file_path="/path/to/local/file.txt"
auth_token="YOUR_AUTH_TOKEN"
endpoint="https://example.com/api/endpoint"

# Check if the file exists
if [ ! -f "$file_path" ]; then
  echo "File not found: $file_path"
  exit 1
fi

# Check if the auth token is provided
if [ -z "$auth_token" ]; then
  echo "Auth token is missing"
  exit 1
fi

# Check if the endpoint is provided
if [ -z "$endpoint" ]; then
  echo "Endpoint is missing"
  exit 1
fi

# Send the cURL request
curl -X POST "$endpoint" \
  -H "Authorization: Bearer $auth_token" \
  -F "file=@$file_path"


------
YourCompositeKey compositeKey = new YourCompositeKey();
compositeKey.setColumnA("valueA");
compositeKey.setColumnB("valueB");
compositeKey.setColumnC("valueC");

YourEntity entity = new YourEntity();
entity.setCompositeKey(compositeKey);
// Set other properties of the entity

yourEntityRepository.save(entity);

=========

@Embeddable
public class YourCompositeKey implements Serializable {

    @Column(name = "column_a")
    private String columnA;

    @Column(name = "column_b")
    private String columnB;

    @Column(name = "column_c")
    private String columnC;

    // Constructors, getters, setters, equals, and hashCode methods
}
===========
@Entity
public class YourEntity {

    @EmbeddedId
    private YourCompositeKey compositeKey;

    // Other entity properties and methods

    public YourCompositeKey getCompositeKey() {
        return compositeKey;
    }

    public void setCompositeKey(YourCompositeKey compositeKey) {
        this.compositeKey = compositeKey;
    }
}
==================
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/tokens")
public class TokenController {
  
  @Autowired
  private TokenService tokenService;
  
  @PostMapping
  public ResponseEntity<String> generateToken(@RequestBody UserCredentials userCredentials) {
    // Validate the user credentials (you can implement your own logic)
    boolean isValid = validateUserCredentials(userCredentials.getUsername(), userCredentials.getPassword());
    
    if (isValid) {
      // Generate a token using the token service
      String token = tokenService.generateToken(userCredentials.getUsername());
      
      return ResponseEntity.ok(token);
    } else {
      return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
    }
  }
  
  private boolean validateUserCredentials(String username, String password) {
    // Implement your own logic to validate the user credentials
    // You can check against a database or any other authentication mechanism
    
    // For this example, we assume that the credentials are valid if the username and password are not empty
    return username != null && !username.isEmpty() && password != null && !password.isEmpty();
  }
}

============
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class TokenService {
  
  private Map<String, String> tokens = new HashMap<>();
  
  public String generateToken(String username) {
    // Generate a unique token using UUID
    String token = UUID.randomUUID().toString();
    
    // Store the token in a map with the username as the key
    tokens.put(username, token);
    
    return token;
  }
  
  public boolean isValidToken(String username, String token) {
    // Check if the provided token matches the stored token for the given username
    String storedToken = tokens.get(username);
    
    return storedToken != null && storedToken.equals(token);
  }
}
=====================
public class UserCredentials {
  
  private String username;
  private String password;
  
  // Add getters and setters
  
  public String getUsername() {
    return username;
  }
  
  public void setUsername(String username) {
    this.username = username;
  }
  
  public String getPassword() {
    return password;
  }
  
  public void setPassword(String password) {
    this.password = password;
  }
}
=====================
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Service
public class TokenService {

  private static final String SECRET_KEY = "your_secret_key"; // Replace with your own secret key
  private static final long EXPIRATION_TIME = 5 * 60 * 1000; // 5 minutes in milliseconds

  private Map<String, String> tokens = new HashMap<>();

  public String generateToken(String username) {
    Date now = new Date();
    Date expiration = new Date(now.getTime() + EXPIRATION_TIME);

    String token = Jwts.builder()
        .setClaims(createClaims(username))
        .setIssuedAt(now)
        .setExpiration(expiration)
        .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
        .compact();

    tokens.put(username, token);
    return token;
  }

  public boolean isValidToken(String username, String token) {
    if (!tokens.containsKey(username) || !tokens.get(username).equals(token)) {
      return false;
    }

    try {
      Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  private Claims createClaims(String username) {
    Claims claims = Jwts.claims();
    claims.put("username", username);
    // Add any additional claims if needed
    return claims;
  }
}
======================
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Service
public class TokenService {

  private static final String SECRET_KEY = "your_secret_key"; // Replace with your own secret key
  private static final long EXPIRATION_TIME = 5 * 60 * 1000; // 5 minutes in milliseconds

  private Map<String, String> tokens = new HashMap<>();

  public String generateToken(String username) {
    Date now = new Date();
    Date expiration = new Date(now.getTime() + EXPIRATION_TIME);

    String token = Jwts.builder()
        .setClaims(createClaims(username))
        .setIssuedAt(now)
        .setExpiration(expiration)
        .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
        .compact();

    tokens.put(username, token);
    return token;
  }

  public boolean isValidToken(String username, String token) {
    if (!tokens.containsKey(username) || !tokens.get(username).equals(token)) {
      return false;
    }

    try {
      Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  public boolean validateToken(String token) {
    try {
      Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  private Claims createClaims(String username) {
    Claims claims = Jwts.claims();
    claims.put("username", username);
    // Add any additional claims if needed
    return claims;
  }
}
